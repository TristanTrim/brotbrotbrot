// Generated by CoffeeScript 1.12.3 --- lol, not anymore. Generated by a deranged programmer with a depricated text editor.
(function() {
  var bgcanvas, bgctx, canvas, centerX, centerY, color, ctx, cx, cy, data, draw, drawAxes, drawBg, drawIteration, drawLoop, f, fromWorld, fromWorldX, fromWorldY, ref, ref1, ref2, render, scale, set, square, step, toWorld, toWorldX, toWorldY, updating, cxmeta, cymeta, panning, panx, pany;

  set = [];

  scale = 200.0;

  centerX = 0;

  centerY = 0;

  step = 1;

  cx = 0;

  cy = 0;

  updating = true;

  panning = false;

  window.setbrot = function(){
    window.f = window.brotfn;
    window.color = window.brotcolor;
    window.updateCanvas = true;
    window.updateBg = true;
  };

  window.setnewt = function(){
    window.f = window.newtonfn;
    window.color = window.newtcolor;
    window.updateCanvas = true;
    window.updateBg = true;
  };

  window.brotfn = function(cx, cy, zx, zy) {
    return [zx * zx - zy * zy + cx, 2 * zx * zy + cy];
  };

  window.newtonfn = function(cx,cy,zx,zy) {
    if(zx==0){
        zx=cx; zy=cy;
        return([zx,zy]);
    }
    let d = ( zx*zx + zy*zy )*( zx*zx + zy*zy )
    return [
        (1/3)*( 2*zx  +  ( zx*zx - zy*zy )/d ),
        (2/3)*( zy - (2*zx*zy)/d )
        ];
  };

  window.f = window.brotfn;

  square = function(zx, zy) {
    return [zx * zx - zy * zy, 2 * zx * zy];
  };

  toWorld = function(x, y) {
    return [toWorldX(x), toWorldY(y)];
  };

  toWorldX = function(x) {
    return (x - canvas.width / 2) / scale + centerX;
  };

  toWorldY = function(y) {
    return (y - canvas.height / 2) / scale + centerY;
  };

  fromWorld = function(x, y) {
    return [fromWorldX(x), fromWorldY(y)];
  };

  fromWorldX = function(x) {
    return (x - centerX) * scale + canvas.width / 2;
  };

  fromWorldY = function(y) {
    return (y - centerY) * scale + canvas.height / 2;
  };

  drawAxes = function() {
    bgctx.strokeStyle = "black";
    bgctx.lineWidth = 1;
    bgctx.beginPath();
    bgctx.moveTo(fromWorldX(-2), fromWorldY(0));
    bgctx.lineTo(fromWorldX(2), fromWorldY(0));
    bgctx.stroke();
    bgctx.beginPath();
    bgctx.moveTo(fromWorldX(0), fromWorldY(-2));
    bgctx.lineTo(fromWorldX(0), fromWorldY(2));
    bgctx.stroke();
    bgctx.beginPath();
    bgctx.arc(fromWorldX(0), fromWorldY(0), 2 * scale, 0, 2 * Math.PI, false);
    return bgctx.stroke();
  };

  drawIteration = function() {
    var i, inSet, j, ref, ref1, zx, zx2, zy, zy2;
    ctx.strokeStyle = "green";
    ctx.fillStyle = "green";
    ctx.lineWidth = 0.5;
    zx = 0;
    zy = 0;
    inSet = true;
    for (i = j = 0; j <= 1000; i = ++j) {
      ref = [zx, zy], zx2 = ref[0], zy2 = ref[1];
      ref1 = window.f(cx, cy, zx, zy), zx = ref1[0], zy = ref1[1];
      ctx.beginPath();
      ctx.moveTo(fromWorldX(zx2), fromWorldY(zy2));
      ctx.lineTo(fromWorldX(zx), fromWorldY(zy));
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(fromWorldX(zx), fromWorldY(zy), 2, 0, 2 * Math.PI, false);
      ctx.fill();
      if (Math.sqrt(zx * zx + zy * zy) > 400.0 ) {
        inSet = false;
        break;
      }
    }
    // add cursor and conv dot
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.arc(fromWorldX(zx), fromWorldY(zy), 2, 0, 2 * Math.PI, false);
    ctx.fill();
    zx = 0;
    zy = 0;
    ref = [zx, zy], zx2 = ref[0], zy2 = ref[1];
    ref1 = window.f(cx, cy, zx, zy), zx = ref1[0], zy = ref1[1];
    ctx.arc(fromWorldX(zx), fromWorldY(zy), 2, 0, 2 * Math.PI, false);
    ctx.fill();

    if (inSet) {
      return set.push([cx, cy]);
    }
  };

  window.brotcolor = function(x, y) {
    var i, j, q, ref2, tx, ty, zx, zy;
    var ref, ref1;
    zx = 0;
    zy = 0;
    zx2= 0;
    zy2= 0;
    tx = 0;
    ty = 0;
    distsum=0;
    q = (x - 0.25) * (x - 0.25) + y * y;
    if (q * (q + (x - 0.25)) < 0.25 * y * y) {
      return 0;
    }
    for (i = j = 0, ref2 = scale / 4; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {

      ref = [zx, zy], zx2 = ref[0], zy2 = ref[1];
      ref1 = window.f(x, y, zx, zy), zx = ref1[0], zy = ref1[1];

      //zy = 2 * zx * zy + y;
      //zx = tx - ty + x;
      tx = zx * zx;
      ty = zy * zy;
      if (tx + ty > 4) {
        return 255.0 * i / 50;
      }
    }
        // default black
    return(0);
  };
  window.newtcolor = function(x, y) {
    colors = [10,30,50];
    var i, j, q, ref2, tx, ty, zx, zy;
    var ref, ref1;
    zx = 0;
    zy = 0;
    zx2= 0;
    zy2= 0;
    tx = 0;
    ty = 0;
   distsum=0;

    for (i=0;i<30;i++){

      ref = [zx, zy], zx2 = ref[0], zy2 = ref[1];
      ref1 = window.f(x, y, zx, zy), zx = ref1[0], zy = ref1[1];

      tx = zx * zx;
      ty = zy * zy;
      tx2 = zx2 * zx2;
      ty2 = zy2 * zy2;
      tdist = tx*tx+ty*ty;

        // time to travel distance // it's pretty but not crisp.
     // distsum = distsum + tdist;
     // if (distsum > 10){
     //    return 255.0 * (i+1) / 20;
     // }

        // color by tridrant after 30 iterations
        // or converge to 1e-5
      if (tdist < 1e-5){
        if (zx <2*zy){
            if (zy<0){
              return(colors[0]);
            }else{
              return(colors[1]);
            }
        }else{
            return(colors[2]);
        }
      }
    }


    // default color split by x pos or x<0 y pos/neg
    if (zx <0){
        if (zy<0){
          return(colors[0]);
        }else{
          return(colors[1]);
        }
    }else{
        return(colors[2]);
    }
  };

  window.color = brotcolor;

  render = function() {
    var c, j, k, offset, ref, ref1, x, xx, y, yy;
    offset = 0;
    for (y = j = 0, ref = bgcanvas.height - 1; 0 <= ref ? j <= ref : j >= ref; y = 0 <= ref ? ++j : --j) {
      for (x = k = 0, ref1 = bgcanvas.width - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; x = 0 <= ref1 ? ++k : --k) {
        xx = toWorldX(x);
        yy = toWorldY(y);
        c = window.color(xx, yy);
        data.data[offset++] = c;
        data.data[offset++] = c;
        data.data[offset++] = c;
        data.data[offset++] = 255;
      }
    }
    return bgctx.putImageData(data, 0, 0);
  };

  draw = function() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return drawIteration();
  };

  drawBg = function() {
    bgctx.clearRect(0, 0, canvas.width, canvas.height);
    drawAxes();
    return render();
  };

  drawLoop = function() {
    requestAnimationFrame(drawLoop);
    if (window.updateBg) {
      drawBg();
      window.updateBg = false;
    }
    if (window.updateCanvas) {
      draw();
      return window.updateCanvas = false;
    }
  };

  Array.prototype.add = function(vector) {
    return [this[0] + vector[0], this[1] + vector[1]];
  };

  Array.prototype.sub = function(vector) {
    return [this[0] - vector[0], this[1] - vector[1]];
  };

  Array.prototype.mul = function(scalar) {
    return [this[0] * scalar, this[1] * scalar];
  };

  Array.prototype.div = function(scalar) {
    return [this[0] / scalar, this[1] / scalar];
  };

  Array.prototype.len = function() {
    return Math.sqrt(this[0] * this[0] + this[1] * this[1]);
  };

  Array.prototype.nor = function() {
    return this.mul(1 / this.len());
  };

  Array.prototype.sum = function() {
    return this.reduce((function(a, b) {
      return a + b.a;
    }), 0);
  };

  Array.prototype.rot = function(theta) {
    return [this[0] * Math.cos(theta) - (this[1] * Math.sin(theta)), this[0] * Math.sin(theta) + this[1] * Math.cos(theta)];
  };

  canvas = document.getElementById("canvas");

  ctx = canvas.getContext("2d");

  bgcanvas = document.getElementById("bg");

  bgctx = bgcanvas.getContext("2d");


  window.requestAnimationFrame = (ref = (ref1 = (ref2 = window.requestAnimationFrame) != null ? ref2 : window.webkitRequestAnimationFrame) != null ? ref1 : window.mozRequestAnimationFrame) != null ? ref : window.msRequestAnimationFrame;

  window.updateCanvas = true;

  window.updateBg = true;

  canvas.onmousemove = (function(_this) {
    return function(event) {
      cxmeta = toWorldX(event.clientX + scrollX -3);
      cymeta = toWorldY(event.clientY + scrollY -5 -0);// if you change 30
                                    // you also need to change css
      if (panning) {
        centerX += (panx - cxmeta);
        centerY += (pany - cymeta);
        window.updateBg = true;
      } else if (updating) {
        cx = cxmeta;
        cy = cymeta;
      }
      return window.updateCanvas = true;
    };
  })(this);

  canvas.onmousedown = (function(_this) {
    return function(event) {
      if (event.which === 1) {
        updating = ! updating;
      }else if (event.which === 2) {
        panx = cxmeta;
        pany = cymeta;
        panning = true;
      }
    };
  })(this);

  canvas.onmouseup = (function(_this) {
    return function(event) {
      panning = false;
    };
  })(this);


  window.onkeydown = (function(_this) {
    return function(event) {
      if (event.keyCode === 82) {
        scale = 200;
        centerX = 0;
        centerY = 0;
        window.updateCanvas = true;
        return window.updateBg = true;
      }else if (event.keyCode === 70) {
        centerX = cxmeta;
        centerY = cymeta;
        scale *= 2;
        window.updateCanvas = true;
        return window.updateBg = true;
      }else if (event.keyCode === 68) {
        scale *= 0.5;
        window.updateCanvas = true;
        return window.updateBg = true;
      }
    };
  })(this);

  function resizeCanvas() {

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    bgcanvas.width = window.innerWidth;
    bgcanvas.height = window.innerHeight;

  }

  resizeCanvas();
  data = bgctx.getImageData(0, 0, bgcanvas.width, bgcanvas.height);

  drawLoop();

}).call(this);
